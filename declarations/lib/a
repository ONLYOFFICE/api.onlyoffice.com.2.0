/**
 * @param {Console} c
 * @param {string} m
 * @param {string} p
 * @param {OperationObject} o
 */
function processOperation(c, m, p, o) {
  let slug = ""
  let title = ""
  let endpoint = `${m} ${p}` // aka signature
  let summary = ""
  let description = ""

  if (o.summary !== undefined) {
    slug = `${o.meta.package}/${slugify(o.summary)}`
    title = o.summary
    summary = o.summary
  } else {
    c.warn(`missing summary for ${endpoint}`)
  }

  if (o.description !== undefined) {
    description = o.description
  } else {
    c.warn(`missing description for ${endpoint}`)
  }

  /** @type {RESTRequest} */
  const request = {}

  request.path = []
  request.query = []

  if (o.parameters !== undefined) {
    o.parameters.forEach((pr) => {
      let p
      switch (pr.in) {
      case "path":
        p = processParameter(c, pr)
        request.path.push(p)
        break
      case "query":
        p = processParameter(c, pr)
        request.query.push(p)
        break
      default:
        c.warn(`unknown parameter location: ${pr.in} for ${endpoint}`)
        break
      }
    })
  }

  request.body = []

  if (o.requestBody !== undefined) {
    /** @type {RequestBodyObject} */
    const b = o.requestBody
    request.body = Object
      .entries(b.content)
      .map(([k, v]) => {
        const r = {}
        if (b.description !== undefined) {
          r.description = b.description
        }
        r.contentType = k
        if (v.schema !== undefined) {
          r.contentSchema = processSchema(c, v.schema)
        }
        return r
      })
  }

  request.examples = []

  const http = {
    syntax: "http",
    // todo: take host from the meta object.
    code: `${m} ${p} HTTP/1.1\nAccept: application/json\nHost: example.com\n`
  }
  request.examples.push(http)

  const cURL = {
    syntax: "shell",
    // todo: omit the -X flag if the method is GET
    code: `curl -L \\n  -X ${m} \\n  -H "Accept: application/json" \\n  "https://example.com${p}"`
  }
  request.examples.push(cURL)

  const responses = []

  if (o.responses !== undefined) {
    Object.entries(o.responses).forEach(([s, _v]) => {
      /** @type {ResponseObject} */
      const v = _v
      if (v.content !== undefined) {
        Object.entries(v.content).forEach(([t, va]) => {
          const r = {}
          r.status = s
          if (v.description !== undefined) {
            r.description = v.description
          }
          r.contentType = t
          if (va.schema !== undefined) {
            r.contentSchema = processSchema(c, va.schema)
          }
          responses.push(r)
        })
      }
    })
  }

  const t = {}

  if (slug.length > 0) {
    t.slug = slug
  }
  if (title.length > 0) {
    t.title = title
  }
  t.endpoint = endpoint
  if (summary.length > 0) {
    t.summary = summary
  }
  if (description.length > 0) {
    t.description = description
  }
  if (request.path.length > 0) {
    if (t.request === undefined) {
      t.request = {}
    }
    t.request.path = request.path
  }
  if (request.query.length > 0) {
    if (t.request === undefined) {
      t.request = {}
    }
    t.request.query = request.query
  }
  if (request.body.length > 0) {
    if (t.request === undefined) {
      t.request = {}
    }
    t.request.body = request.body
  }
  if (request.examples.length > 0) {
    if (t.request === undefined) {
      t.request = {}
    }
    t.request.examples = request.examples
  }
  if (responses.length > 0) {
    t.responses = responses
  }

  return t

  // if (false && o.security !== undefined) {
  //   t.security = o.security.flatMap((item) => {
  //     return Object.entries(item).map(([k, v]) => {
  //       return {
  //         id: k,
  //         scopes: v,
  //       }
  //     })
  //   })
  // }

  // aka sections
  // headers
  // pathParameters
  // queryParameters
  // body
  // responses
}

/**
 * @param {Console} c
 * @param {ReferenceObject | ParameterObject} o
 */
function processParameter(c, o) {
  if (o["$ref"] !== undefined) {
    // @ts-ignore
    return processReference(o)
  }

  /** @type {ParameterObject} */
  // @ts-ignore
  const _o = o
  o = _o

  let p = {
    identifier: o.name
  }

  if (o.description !== undefined) {
    p.description = o.description
  }
  if (o.required === true) {
    p.required = true
  }

  p = {
    ...p,
    ...processSchema(c, o.schema)
  }

  return p
}

// /**
//  * @param {string} t
//  * @param {MediaTypeObject} o
//  */
// function parseMediaType(t, o) {}

/**
 * @param {Console} c
 * @param {ReferenceObject | SchemaObject} s
 */
function processSchema(c, s) {
  if (s["$ref"] !== undefined) {
    // @ts-ignore
    return processReference(s)
  }

  /** @type {SchemaObject} */
  const _s = s
  s = _s

  switch (s.type) {
  case "array":
    return processArray(c, s)
  case "boolean":
  case "integer":
  case "number":
    return processNonArray(s)
  case "object":
    return processObject(c, s)
  case "string":
    return processNonArray(s)
  default:
    c.warn(`unknown schema type: ${s.type}`)
    return processUnknown(s)
  }
}

/**
 * @param {ReferenceObject} s
 */
function processReference(s) {
  return {
    type: "reference",
    id: s["$ref"].replace("#/components/schemas/", "")
  }
}

/**
 * @param {Console} c
 * @param {ArraySchemaObject} s
 */
function processArray(c, s) {
  const t = {
    type: "array",
    items: []
  }

  if (s.items === undefined) {
    c.warn("missing items for array schema")
    t.items.push({
      type: "unknown"
    })
  } else {
    t.items = processSchema(c, s.items)
  }

  return t
}

/**
 * @param {Console} c
 * @param {NonArraySchemaObject} s
 */
function processObject(c, s) {
  const t = {
    type: "object",
    properties: []
  }

  if (s.properties === undefined) {
    c.warn("missing properties for object schema")
    t.properties.push({
      identifier: "unknown",
      type: "unknown"
    })
  } else {
    t.properties = Object
      .entries(s.properties)
      .map(([k, v]) => {
        let p = {
          identifier: k
        }
        if (v.description !== undefined) {
          p.description = v.description
        }
        if (v.example !== undefined) {
          p.example = v.example
        }
        p = {
          ...p,
          ...processSchema(c, v)
        }
        return p
      })
  }

  return t
}

/**
 * @param {NonArraySchemaObject} s
 */
function processNonArray(s) {
  const t = {}
  if (s.format !== undefined) {
    t.format = s.format
  }
  t.type = s.type
  return t
}
